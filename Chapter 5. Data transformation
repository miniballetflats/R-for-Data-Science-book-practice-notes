5 Data transformation

library(nycflights13)
library(tidyverse)

flights

# A tibble: 336,776 x 19
    year month   day dep_time sched_dep_time dep_delay arr_time sched_arr_time arr_delay
   <int> <int> <int>    <int>          <int>     <dbl>    <int>          <int>     <dbl>
 1  2013     1     1      517            515         2      830            819        11
 2  2013     1     1      533            529         4      850            830        20
 3  2013     1     1      542            540         2      923            850        33
 4  2013     1     1      544            545        -1     1004           1022       -18
 5  2013     1     1      554            600        -6      812            837       -25
 6  2013     1     1      554            558        -4      740            728        12
 7  2013     1     1      555            600        -5      913            854        19
 8  2013     1     1      557            600        -3      709            723       -14
 9  2013     1     1      557            600        -3      838            846        -8
10  2013     1     1      558            600        -2      753            745         8
# ... with 336,766 more rows, and 10 more variables: carrier <chr>, flight <int>,
#   tailnum <chr>, origin <chr>, dest <chr>, air_time <dbl>, distance <dbl>, hour <dbl>,
#   minute <dbl>, time_hour <dttm>

This data frame contains all 336,776 flights that 
departed from New York City in 2013. 
The data comes from the US Bureau of Transportation Statistics, 
and is documented in ?flights.

#int stands for integers.
#dbl stands for doubles, or real numbers.
#chr stands for character vectors, or strings.
#dttm stands for date-times (a date + a time).

#lgl stands for logical, vectors that contain only TRUE or FALSE.
#fctr stands for factors, which R uses to represent categorical 
variables with fixed possible values.
#date stands for dates.

#Pick observations by their values (filter()).
#Reorder the rows (arrange()).
#Pick variables by their names (select()).
#Create new variables with functions of existing variables (mutate()). & transmute()
#Collapse many values down to a single summary (summarise())

used in conjunction with group_by() which changes the scope of each function 
from operating on the entire dataset to operating on it group-by-group

5.2 Filter rows with filter()

filter(flights, month==1, day==1)
jan1<- filter(flights, month==1, day==1)

jan1

dec25<-filter(flights, month==12,day==25)

dec25

5.2.1 Comparisons

#R provides the standard suite: >, >=, <, <=, != (not equal), and == (equal).

5.2.2 Logical operators

Multiple arguments to filter() are combined with “and”: 
every expression must be true in order for a row to be included in the output.
Boolean operators yourself: & is “and”, | is “or”, and ! is “not”.

The following code finds all flights that departed in November or December
filter(flights, month == 11 | month == 12)

alternative, hort-hand for this problem is x %in% y

nov_dec<-filter(flights, month %in% c(11,12))

nov_dec

alternative : filter(flights, !(month %in% c(1,2,3,4,5,6,7,8,9,10)))

filter(flights, !(arr_delay>120|dep_delay>120))

filter(flights, arr_delay <= 120, dep_delay <= 120)

5.2.3 Missing values

If you want to determine if a value is missing, use is.na():

is.na(x)
#> [1] TRUE

df <- tibble(x=c(1,NA, 3,5))

df
# A tibble: 4 x 1
      x
  <dbl>
1     1
2    NA
3     3
4     5

filter(df, x>1)
# A tibble: 2 x 1
      x
  <dbl>
1     3
2     5

filter(df, is.na(x)|x>1)
# A tibble: 3 x 1
x
<dbl>
    1    NA
2     3
3     5

5.2.4 Exercise
#Find all flights that

#Had an arrival delay of two or more hours
filter(flights, arr_delay>=120)

#Flew to Houston (IAH or HOU)
https://www.transtats.bts.gov/DL_SelectFields.asp?Table_ID=236
filter(flights, dest=="IAH"|dest=="HOU")
filter(flights, dest %in% c("IAH", "HOU"))

#Were operated by United, American, or Delta
https://www.transtats.bts.gov/DL_SelectFields.asp?Table_ID=236
UA	United Air Lines Inc.
AA	American Airlines Inc.
DL	Delta Air Lines Inc.
filter(flights, carrier=="AA"|carrier=="UA"|carrier=="DL")
filter(flights, carrier %in% c("AA", "DL", "UA"))

Departed in summer (July, August, and September)
filter(flights, month==7|month==8|month==9)
filter(flights, month %in% c(7,8,9))
filter(flights, month %in% 7:9)
filter(flights, !(month %in% c(1,2,3,4,5,6,10,11,12)))

Arrived more than two hours late, but didn’t leave late
filter(flights, arr_delay>120 & dep_delay<=0)

Were delayed by at least an hour, but made up over 30 minutes in flight
# For example, if dep_delay is 10 minutes late then arr_delay should be
# 10 mins lates. 10 - 10 = 0, so air time was on time.
# If dep_delay is 10 minutes late but arr_delay  is -20 minutes earlier, then
# arr_delay SHOULD'VE been 10 but instead is -20 (because of 30 catch up), so
# 10 - (-20) = 30.
filter(flights, dep_delay >= 60, (dep_delay - arr_delay > 30))

Departed between midnight and 6am (inclusive)
filter(flights, dep_time >= 2400 | dep_time <= 600)

Another useful dplyr filtering helper is between(). 
What does it do? Can you use it to simplify the code needed to 
answer the previous challenges?
filter(flights, between(dep_time, 601, 2359))

How many flights have a missing dep_time? 
What other variables are missing? 
What might these rows represent?
sum(is.na(flights$dep_time))

Why is NA ^ 0 not missing? Why is NA | TRUE not missing? 
  Why is FALSE & NA not missing? Can you figure out the general rule? 
  (NA * 0 is a tricky counterexample!)

Because anything that is `^ 0` equals `1`.
Because NA | TRUE is saying whether one of the 
two is `TRUE` and the second one is.
Because at least one of the two expressions can be tested: 
  FALSE & NA. In NA & NA neither can be tested and the results is `NA & NA`.

The general rule is that whenever there is a logical expressions, 
if one can be tested, then the result shouldn't be `NA`. 
And any operation that the results is determined, 
regardless of the number, 
the inputting `NA` does not affect the result.

5.3.1 Exercises

How could you use arrange() to sort all missing values to the start? (Hint: use is.na()).

df<- tibble(x=c(5,2,NA),
+ y=c(2,NA,2))
> 

> df
# A tibble: 3 x 2
      x     y
  <dbl> <dbl>
1     5     2
2     2    NA
3    NA     2
> rowSums(df)
[1]  7 NA NA
> arrange(df, desc(is.na(x)))
# A tibble: 3 x 2
      x     y
  <dbl> <dbl>
1    NA     2
2     5     2
3     2    NA
> arrange(df, -(is.na(x)))
# A tibble: 3 x 2
      x     y
  <dbl> <dbl>
1    NA     2
2     5     2
3     2    NA

#Sort flights to find the most delayed flights. Find the flights that left earliest.
arrange(flights, dep_delay)
arrange(flights, desc(dep_delay))

#Sort flights to find the fastest flights.
arrange(flights, air_time)

Which flights travelled the longest? Which travelled the shortest?

#longest
flights %>%
+ arrange(desc(air_time)) %>%
+ select(carrier,tailnum, flight, air_time)

#shortest
flights %>%
+ arrange(-desc(air_time)) %>%
+ select(carrier,tailnum, flight, air_time)

5.4 Select columns with select()
select() allows you to rapidly zoom in on a useful subset using operations based on the names of the variables


Brainstorm as many ways as possible to select dep_time, dep_delay, arr_time, and arr_delay from flights.

select(flights, dep_time, dep_delay, arr_time, arr_delay)
select(flights, dep_time, dep_delay, arr_time, arr_delay, everything())
arrange(flights, dep_time, dep_delay, arr_time, arr_delay)

select(flights, starts_with("dep"), starts_with("arr"))

vers<-c("dep_time", "dep_delay", "arr_time", "arr_delay")

select(flights, one_of(vers))

dont really understand but have the formula.

select_(flights, .dots = vers)
select_(flights, "dep_time", "dep_delay", "arr_time", "arr_delay")
select(flights, matches("dep"), matches("arr"), -matches("sched"), -carrier)
select(flights, contains("dep"), contains("arr"), -contains("sched"), -carrier)
select(flights, matches("^dep|^arr"))
select(flights, matches("time$|delay$"), -contains("sched"), -contains("air"))
select(flights, matches("^dep|arr_delay|time$"))


#What happens if you include the name of a variable multiple times in a select() call?

select(flights, dep_time, dep_time)
# it will only appear 1 time

What does the one_of() function do? Why might it be helpful in conjunction with this vector?
no

vars

Does the result of running the following code surprise you? How do the select helpers deal with case by default? How can you change that default?

select(flights, contains("TIME"))
select(flights, contains("TIME", ignore.case = F))



5.5 Add new variables with mutate()

mutate() always adds new columns at the end of your dataset so we’ll start 
by creating a narrower dataset so we can see the new variables

flights_sml <-select(flights, 
year:day, 
ends_with("delay"),
distance,
air_time)

flights_sml

mutate(flights_sml,
gain= dep_delay - arr_delay,
speed= distance/air_time*60
)

mutate(flights_sml,
  gain = dep_delay - arr_delay,
  hours = air_time / 60,
  gain_per_hour = gain / hours
)

# A tibble: 336,776 x 10
    year month   day dep_delay arr_delay distance air_time  gain hours gain_per_hour
   <int> <int> <int>     <dbl>     <dbl>    <dbl>    <dbl> <dbl> <dbl>         <dbl>
 1  2013     1     1         2        11     1400      227    -9 3.78          -2.38
 2  2013     1     1         4        20     1416      227   -16 3.78          -4.23
 3  2013     1     1         2        33     1089      160   -31 2.67         -11.6 
 4  2013     1     1        -1       -18     1576      183    17 3.05           5.57
 5  2013     1     1        -6       -25      762      116    19 1.93           9.83
 6  2013     1     1        -4        12      719      150   -16 2.5           -6.4 
 7  2013     1     1        -5        19     1065      158   -24 2.63          -9.11
 8  2013     1     1        -3       -14      229       53    11 0.883         12.5 
 9  2013     1     1        -3        -8      944      140     5 2.33           2.14
10  2013     1     1        -2         8      733      138   -10 2.3           -4.35

#keep the new variables, use transmute()
transmute(flights_sml,
  gain = dep_delay - arr_delay,
  hours = air_time / 60,
  gain_per_hour = gain / hours
)

# A tibble: 336,776 x 3
    gain hours gain_per_hour
   <dbl> <dbl>         <dbl>
 1    -9 3.78          -2.38
 2   -16 3.78          -4.23
 3   -31 2.67         -11.6 
 4    17 3.05           5.57
 5    19 1.93           9.83
 6   -16 2.5           -6.4 
 7   -24 2.63          -9.11
 8    11 0.883         12.5 
 9     5 2.33           2.14
10   -10 2.3           -4.35
# ... with 336,766 more rows

5.5.1 Useful creation functions

5.5.1 Useful creation functions

Arithmetic operators: +, -, *, /, ^. These are all vectorised, using the so called “recycling rules”. 
If one parameter is shorter than the other, it will be automatically extended to be the same length. 
This is most useful when one of the arguments is a single number: air_time / 60, hours * 60 + minute, etc.

Arithmetic operators are also useful in conjunction with the aggregate functions you’ll learn about later. 
For example, x / sum(x) calculates the proportion of a total, and y - mean(y) computes the difference from the mean.

Modular arithmetic: %/% (integer division) and %% (remainder), where x == y * (x %/% y) + (x %% y). 
Modular arithmetic is a handy tool because it allows you to break integers up into pieces. 
For example, in the flights dataset, you can compute hour and minute from dep_time with:

Modular arithmetic: %/% (integer division) and %% (remainder)


> transmute(flights, dep_time,
+ hour = dep_time %/% 100,
+ minute = dep_time %% 100
+ )
# A tibble: 336,776 x 3
   dep_time  hour minute
      <int> <dbl>  <dbl>
 1      517     5     17
 2      533     5     33
 3      542     5     42
 4      544     5     44
 5      554     5     54
 6      554     5     54
 7      555     5     55
 8      557     5     57
 9      557     5     57
10      558     5     58
# ... with 336,766 more rows
> x <- 1:10
> lag(x)
 [1] NA  1  2  3  4  5  6  7  8  9
> lead(x)
 [1]  2  3  4  5  6  7  8  9 10 NA
> x
 [1]  1  2  3  4  5  6  7  8  9 10
> cumsum(x)
 [1]  1  3  6 10 15 21 28 36 45 55
> cummean(x)
 [1] 1.0 1.5 2.0 2.5 3.0 3.5 4.0 4.5 5.0 5.5



y<- c(1,2,2,NA,3,4)
> y
[1]  1  2  2 NA  3  4
> min_rank(y)
[1]  1  2  2 NA  4  5
> min_rank(desc(y))
[1]  5  3  3 NA  2  1
> row_number(y)
[1]  1  2  3 NA  4  5
> dense_rank(y)
[1]  1  2  2 NA  3  4
> percent_rank(y)
[1] 0.00 0.25 0.25   NA 0.75 1.00
> cume_dist(y)
[1] 0.2 0.6 0.6  NA 0.8 1.0

5.5.2 Exercises

transmute(flights, dep_time,
hour = dep_time %/% 100,
minute = dep_time %% 100
)

# A tibble: 336,776 x 3
   dep_time  hour minute
      <int> <dbl>  <dbl>
 1      517     5     17
 2      533     5     33
 3      542     5     42
 4      544     5     44
 5      554     5     54
 6      554     5     54
 7      555     5     55
 8      557     5     57
 9      557     5     57
10      558     5     58
# ... with 336,766 more rows

transmute(flights, sched_dep_time,
hour = dep_time %/% 100,
minute = dep_time %% 100
)

# A tibble: 336,776 x 3
   sched_dep_time  hour minute
            <int> <dbl>  <dbl>
 1            515     5     17
 2            529     5     33
 3            540     5     42
 4            545     5     44
 5            600     5     54
 6            558     5     54
 7            600     5     55
 8            600     5     57
 9            600     5     57
10            600     5     58
# ... with 336,766 more rows

5.5.2 Exercises

Currently dep_time and sched_dep_time are convenient to look at, 
but hard to compute with because they’re not really continuous numbers. 
Convert them to a more convenient representation of number of minutes since midnight.

# dep_time in mins

transmute(flights, dep_time,
hour = dep_time %/% 100*60,
minute = dep_time %% 100,
total =hour+minute
)

# A tibble: 336,776 x 4
   dep_time  hour minute total
      <int> <dbl>  <dbl> <dbl>
 1      517   300     17   317
 2      533   300     33   333
 3      542   300     42   342
 4      544   300     44   344
 5      554   300     54   354
 6      554   300     54   354
 7      555   300     55   355
 8      557   300     57   357
 9      557   300     57   357
10      558   300     58   358
# ... with 336,766 more rows

# sched_dep_time in mins

transmute(flights, sched_dep_time,
hour = sched_dep_time %/% 100*60,
minute = sched_dep_time %% 100,
total =hour+minute
)

# A tibble: 336,776 x 4
   sched_dep_time  hour minute total
            <int> <dbl>  <dbl> <dbl>
 1            515   300     15   315
 2            529   300     29   329
 3            540   300     40   340
 4            545   300     45   345
 5            600   360      0   360
 6            558   300     58   358
 7            600   360      0   360
 8            600   360      0   360
 9            600   360      0   360
10            600   360      0   360
# ... with 336,766 more rows


Compare air_time with arr_time - dep_time. 
What do you expect to see? 
What do you see? What do you need to do to fix it?

was not able to solve. 
Answer from https://github.com/cimentadaj/R4DS-Solutions/blob/master/Ch3.Rmd

hours2mins <- function(x) {
  x %/% 100 * 60 + x %% 100
}
