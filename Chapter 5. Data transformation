5 Data transformation

library(nycflights13)
library(tidyverse)

flights

# A tibble: 336,776 x 19
    year month   day dep_time sched_dep_time dep_delay arr_time sched_arr_time arr_delay
   <int> <int> <int>    <int>          <int>     <dbl>    <int>          <int>     <dbl>
 1  2013     1     1      517            515         2      830            819        11
 2  2013     1     1      533            529         4      850            830        20
 3  2013     1     1      542            540         2      923            850        33
 4  2013     1     1      544            545        -1     1004           1022       -18
 5  2013     1     1      554            600        -6      812            837       -25
 6  2013     1     1      554            558        -4      740            728        12
 7  2013     1     1      555            600        -5      913            854        19
 8  2013     1     1      557            600        -3      709            723       -14
 9  2013     1     1      557            600        -3      838            846        -8
10  2013     1     1      558            600        -2      753            745         8
# ... with 336,766 more rows, and 10 more variables: carrier <chr>, flight <int>,
#   tailnum <chr>, origin <chr>, dest <chr>, air_time <dbl>, distance <dbl>, hour <dbl>,
#   minute <dbl>, time_hour <dttm>

This data frame contains all 336,776 flights that 
departed from New York City in 2013. 
The data comes from the US Bureau of Transportation Statistics, 
and is documented in ?flights.

#int stands for integers.
#dbl stands for doubles, or real numbers.
#chr stands for character vectors, or strings.
#dttm stands for date-times (a date + a time).

#lgl stands for logical, vectors that contain only TRUE or FALSE.
#fctr stands for factors, which R uses to represent categorical 
variables with fixed possible values.
#date stands for dates.

#Pick observations by their values (filter()).
#Reorder the rows (arrange()).
#Pick variables by their names (select()).
#Create new variables with functions of existing variables (mutate()). & transmute()
#Collapse many values down to a single summary (summarise())

used in conjunction with group_by() which changes the scope of each function 
from operating on the entire dataset to operating on it group-by-group

5.2 Filter rows with filter()

filter(flights, month==1, day==1)
jan1<- filter(flights, month==1, day==1)

jan1

dec25<-filter(flights, month==12,day==25)

dec25

5.2.1 Comparisons

#R provides the standard suite: >, >=, <, <=, != (not equal), and == (equal).

5.2.2 Logical operators

Multiple arguments to filter() are combined with “and”: 
every expression must be true in order for a row to be included in the output.
Boolean operators yourself: & is “and”, | is “or”, and ! is “not”.

The following code finds all flights that departed in November or December
filter(flights, month == 11 | month == 12)

alternative, hort-hand for this problem is x %in% y

nov_dec<-filter(flights, month %in% c(11,12))

nov_dec

alternative : filter(flights, !(month %in% c(1,2,3,4,5,6,7,8,9,10)))

filter(flights, !(arr_delay>120|dep_delay>120))

filter(flights, arr_delay <= 120, dep_delay <= 120)

5.2.3 Missing values

If you want to determine if a value is missing, use is.na():

is.na(x)
#> [1] TRUE

df <- tibble(x=c(1,NA, 3,5))

df
# A tibble: 4 x 1
      x
  <dbl>
1     1
2    NA
3     3
4     5

filter(df, x>1)
# A tibble: 2 x 1
      x
  <dbl>
1     3
2     5

filter(df, is.na(x)|x>1)
# A tibble: 3 x 1
x
<dbl>
    1    NA
2     3
3     5

5.2.4 Exercise
#Find all flights that

#Had an arrival delay of two or more hours
filter(flights, arr_delay>=120)

#Flew to Houston (IAH or HOU)
https://www.transtats.bts.gov/DL_SelectFields.asp?Table_ID=236
filter(flights, dest=="IAH"|dest=="HOU")
filter(flights, dest %in% c("IAH", "HOU"))

#Were operated by United, American, or Delta
https://www.transtats.bts.gov/DL_SelectFields.asp?Table_ID=236
UA	United Air Lines Inc.
AA	American Airlines Inc.
DL	Delta Air Lines Inc.
filter(flights, carrier=="AA"|carrier=="UA"|carrier=="DL")
filter(flights, carrier %in% c("AA", "DL", "UA"))

Departed in summer (July, August, and September)
filter(flights, month==7|month==8|month==9)
filter(flights, month %in% c(7,8,9))
filter(flights, month %in% 7:9)
filter(flights, !(month %in% c(1,2,3,4,5,6,10,11,12)))

Arrived more than two hours late, but didn’t leave late
filter(flights, arr_delay>120 & dep_delay<=0)

Were delayed by at least an hour, but made up over 30 minutes in flight
# For example, if dep_delay is 10 minutes late then arr_delay should be
# 10 mins lates. 10 - 10 = 0, so air time was on time.
# If dep_delay is 10 minutes late but arr_delay  is -20 minutes earlier, then
# arr_delay SHOULD'VE been 10 but instead is -20 (because of 30 catch up), so
# 10 - (-20) = 30.
filter(flights, dep_delay >= 60, (dep_delay - arr_delay > 30))

Departed between midnight and 6am (inclusive)
filter(flights, dep_time >= 2400 | dep_time <= 600)

Another useful dplyr filtering helper is between(). 
What does it do? Can you use it to simplify the code needed to 
answer the previous challenges?
filter(flights, between(dep_time, 601, 2359))

How many flights have a missing dep_time? 
What other variables are missing? 
What might these rows represent?
sum(is.na(flights$dep_time))

Why is NA ^ 0 not missing? Why is NA | TRUE not missing? 
  Why is FALSE & NA not missing? Can you figure out the general rule? 
  (NA * 0 is a tricky counterexample!)

Because anything that is `^ 0` equals `1`.
Because NA | TRUE is saying whether one of the 
two is `TRUE` and the second one is.
Because at least one of the two expressions can be tested: 
  FALSE & NA. In NA & NA neither can be tested and the results is `NA & NA`.

The general rule is that whenever there is a logical expressions, 
if one can be tested, then the result shouldn't be `NA`. 
And any operation that the results is determined, 
regardless of the number, 
the inputting `NA` does not affect the result.

5.3.1 Exercises

How could you use arrange() to sort all missing values to the start? (Hint: use is.na()).

df<- tibble(x=c(5,2,NA),
+ y=c(2,NA,2))
> 

> df
# A tibble: 3 x 2
      x     y
  <dbl> <dbl>
1     5     2
2     2    NA
3    NA     2
> rowSums(df)
[1]  7 NA NA
> arrange(df, desc(is.na(x)))
# A tibble: 3 x 2
      x     y
  <dbl> <dbl>
1    NA     2
2     5     2
3     2    NA
> arrange(df, -(is.na(x)))
# A tibble: 3 x 2
      x     y
  <dbl> <dbl>
1    NA     2
2     5     2
3     2    NA

#Sort flights to find the most delayed flights. Find the flights that left earliest.
arrange(flights, dep_delay)
arrange(flights, desc(dep_delay))

#Sort flights to find the fastest flights.
arrange(flights, air_time)

Which flights travelled the longest? Which travelled the shortest?

#longest
flights %>%
+ arrange(desc(air_time)) %>%
+ select(carrier,tailnum, flight, air_time)

#shortest
flights %>%
+ arrange(-desc(air_time)) %>%
+ select(carrier,tailnum, flight, air_time)

5.4 Select columns with select()
select() allows you to rapidly zoom in on a useful subset using operations based on the names of the variables


Brainstorm as many ways as possible to select dep_time, dep_delay, arr_time, and arr_delay from flights.

select(flights, dep_time, dep_delay, arr_time, arr_delay)
select(flights, dep_time, dep_delay, arr_time, arr_delay, everything())
arrange(flights, dep_time, dep_delay, arr_time, arr_delay)

select(flights, starts_with("dep"), starts_with("arr"))

vers<-c("dep_time", "dep_delay", "arr_time", "arr_delay")

select(flights, one_of(vers))

dont really understand but have the formula.

select_(flights, .dots = vers)
select_(flights, "dep_time", "dep_delay", "arr_time", "arr_delay")
select(flights, matches("dep"), matches("arr"), -matches("sched"), -carrier)
select(flights, contains("dep"), contains("arr"), -contains("sched"), -carrier)
select(flights, matches("^dep|^arr"))
select(flights, matches("time$|delay$"), -contains("sched"), -contains("air"))
select(flights, matches("^dep|arr_delay|time$"))


#What happens if you include the name of a variable multiple times in a select() call?

select(flights, dep_time, dep_time)
# it will only appear 1 time

What does the one_of() function do? Why might it be helpful in conjunction with this vector?
no

vars

Does the result of running the following code surprise you? How do the select helpers deal with case by default? How can you change that default?

select(flights, contains("TIME"))
select(flights, contains("TIME", ignore.case = F))



5.5 Add new variables with mutate()

mutate() always adds new columns at the end of your dataset so we’ll start 
by creating a narrower dataset so we can see the new variables

flights_sml <-select(flights, 
year:day, 
ends_with("delay"),
distance,
air_time)

flights_sml

mutate(flights_sml,
gain= dep_delay - arr_delay,
speed= distance/air_time*60
)

mutate(flights_sml,
  gain = dep_delay - arr_delay,
  hours = air_time / 60,
  gain_per_hour = gain / hours
)

# A tibble: 336,776 x 10
    year month   day dep_delay arr_delay distance air_time  gain hours gain_per_hour
   <int> <int> <int>     <dbl>     <dbl>    <dbl>    <dbl> <dbl> <dbl>         <dbl>
 1  2013     1     1         2        11     1400      227    -9 3.78          -2.38
 2  2013     1     1         4        20     1416      227   -16 3.78          -4.23
 3  2013     1     1         2        33     1089      160   -31 2.67         -11.6 
 4  2013     1     1        -1       -18     1576      183    17 3.05           5.57
 5  2013     1     1        -6       -25      762      116    19 1.93           9.83
 6  2013     1     1        -4        12      719      150   -16 2.5           -6.4 
 7  2013     1     1        -5        19     1065      158   -24 2.63          -9.11
 8  2013     1     1        -3       -14      229       53    11 0.883         12.5 
 9  2013     1     1        -3        -8      944      140     5 2.33           2.14
10  2013     1     1        -2         8      733      138   -10 2.3           -4.35

#keep the new variables, use transmute()
transmute(flights_sml,
  gain = dep_delay - arr_delay,
  hours = air_time / 60,
  gain_per_hour = gain / hours
)

# A tibble: 336,776 x 3
    gain hours gain_per_hour
   <dbl> <dbl>         <dbl>
 1    -9 3.78          -2.38
 2   -16 3.78          -4.23
 3   -31 2.67         -11.6 
 4    17 3.05           5.57
 5    19 1.93           9.83
 6   -16 2.5           -6.4 
 7   -24 2.63          -9.11
 8    11 0.883         12.5 
 9     5 2.33           2.14
10   -10 2.3           -4.35
# ... with 336,766 more rows

5.5.1 Useful creation functions

5.5.1 Useful creation functions

Arithmetic operators: +, -, *, /, ^. These are all vectorised, using the so called “recycling rules”. 
If one parameter is shorter than the other, it will be automatically extended to be the same length. 
This is most useful when one of the arguments is a single number: air_time / 60, hours * 60 + minute, etc.

Arithmetic operators are also useful in conjunction with the aggregate functions you’ll learn about later. 
For example, x / sum(x) calculates the proportion of a total, and y - mean(y) computes the difference from the mean.

Modular arithmetic: %/% (integer division) and %% (remainder), where x == y * (x %/% y) + (x %% y). 
Modular arithmetic is a handy tool because it allows you to break integers up into pieces. 
For example, in the flights dataset, you can compute hour and minute from dep_time with:

Modular arithmetic: %/% (integer division) and %% (remainder)


> transmute(flights, dep_time,
+ hour = dep_time %/% 100,
+ minute = dep_time %% 100
+ )
# A tibble: 336,776 x 3
   dep_time  hour minute
      <int> <dbl>  <dbl>
 1      517     5     17
 2      533     5     33
 3      542     5     42
 4      544     5     44
 5      554     5     54
 6      554     5     54
 7      555     5     55
 8      557     5     57
 9      557     5     57
10      558     5     58
# ... with 336,766 more rows
> x <- 1:10
> lag(x)
 [1] NA  1  2  3  4  5  6  7  8  9
> lead(x)
 [1]  2  3  4  5  6  7  8  9 10 NA
> x
 [1]  1  2  3  4  5  6  7  8  9 10
> cumsum(x)
 [1]  1  3  6 10 15 21 28 36 45 55
> cummean(x)
 [1] 1.0 1.5 2.0 2.5 3.0 3.5 4.0 4.5 5.0 5.5



y<- c(1,2,2,NA,3,4)
> y
[1]  1  2  2 NA  3  4
> min_rank(y)
[1]  1  2  2 NA  4  5
> min_rank(desc(y))
[1]  5  3  3 NA  2  1
> row_number(y)
[1]  1  2  3 NA  4  5
> dense_rank(y)
[1]  1  2  2 NA  3  4
> percent_rank(y)
[1] 0.00 0.25 0.25   NA 0.75 1.00
> cume_dist(y)
[1] 0.2 0.6 0.6  NA 0.8 1.0

5.5.2 Exercises

transmute(flights, dep_time,
hour = dep_time %/% 100,
minute = dep_time %% 100
)

# A tibble: 336,776 x 3
   dep_time  hour minute
      <int> <dbl>  <dbl>
 1      517     5     17
 2      533     5     33
 3      542     5     42
 4      544     5     44
 5      554     5     54
 6      554     5     54
 7      555     5     55
 8      557     5     57
 9      557     5     57
10      558     5     58
# ... with 336,766 more rows

transmute(flights, sched_dep_time,
hour = dep_time %/% 100,
minute = dep_time %% 100
)

# A tibble: 336,776 x 3
   sched_dep_time  hour minute
            <int> <dbl>  <dbl>
 1            515     5     17
 2            529     5     33
 3            540     5     42
 4            545     5     44
 5            600     5     54
 6            558     5     54
 7            600     5     55
 8            600     5     57
 9            600     5     57
10            600     5     58
# ... with 336,766 more rows

5.5.2 Exercises

Currently dep_time and sched_dep_time are convenient to look at, 
but hard to compute with because they’re not really continuous numbers. 
Convert them to a more convenient representation of number of minutes since midnight.

# dep_time in mins

transmute(flights, dep_time,
hour = dep_time %/% 100*60,
minute = dep_time %% 100,
total =hour+minute
)

# A tibble: 336,776 x 4
   dep_time  hour minute total
      <int> <dbl>  <dbl> <dbl>
 1      517   300     17   317
 2      533   300     33   333
 3      542   300     42   342
 4      544   300     44   344
 5      554   300     54   354
 6      554   300     54   354
 7      555   300     55   355
 8      557   300     57   357
 9      557   300     57   357
10      558   300     58   358
# ... with 336,766 more rows

# sched_dep_time in mins

transmute(flights, sched_dep_time,
hour = sched_dep_time %/% 100*60,
minute = sched_dep_time %% 100,
total =hour+minute
)

# A tibble: 336,776 x 4
   sched_dep_time  hour minute total
            <int> <dbl>  <dbl> <dbl>
 1            515   300     15   315
 2            529   300     29   329
 3            540   300     40   340
 4            545   300     45   345
 5            600   360      0   360
 6            558   300     58   358
 7            600   360      0   360
 8            600   360      0   360
 9            600   360      0   360
10            600   360      0   360
# ... with 336,766 more rows


Compare air_time with arr_time - dep_time. 
What do you expect to see? 
What do you see? What do you need to do to fix it?

was not able to solve. 
Answer from https://github.com/cimentadaj/R4DS-Solutions/blob/master/Ch3.Rmd


Compare dep_time, sched_dep_time, and dep_delay. How would you expect those three numbers to be related?

> hours2mins <-function(x){
+ x%/% 100 * 60 + x%% 100
+ }
> 

> select(flights, contains("dep")) %>%
+ mutate(dep_time_two= hours2mins(dep_time)- hours2mins(sched_dep_time))
# A tibble: 336,776 x 4
   dep_time sched_dep_time dep_delay dep_time_two
      <int>          <int>     <dbl>        <dbl>
 1      517            515         2            2
 2      533            529         4            4
 3      542            540         2            2
 4      544            545        -1           -1
 5      554            600        -6           -6
 6      554            558        -4           -4
 7      555            600        -5           -5
 8      557            600        -3           -3
 9      557            600        -3           -3
10      558            600        -2           -2
# ... with 336,766 more rows
> 

> # these two numbers don’t match because we aren’t accounting for flights
> # where the departure time is the next day from the scheduled departure time.
> 

> select(flights, contains("dep")) %>%
+ mutate(dep_time_two=hours2mins(dep_time)-hours2mins(sched_dep_time)) %>%
+ filter(dep_delay != dep_time_two) %>%
+ mutate(dep_time_two = hours2mins(dep_time) - hours2mins(sched_dep_time - 2400))
# A tibble: 1,207 x 4
   dep_time sched_dep_time dep_delay dep_time_two
      <int>          <int>     <dbl>        <dbl>
 1      848           1835       853          853
 2       42           2359        43           43
 3      126           2250       156          156
 4       32           2359        33           33
 5       50           2145       185          185
 6      235           2359       156          156
 7       25           2359        26           26
 8      106           2245       141          141
 9       14           2359        15           15
10       37           2230       127          127
# ... with 1,197 more rows
> 
Find the 10 most delayed flights using a ranking function. How do you want to handle ties? Carefully read the documentation for min_rank()

> flights %>%
+ filter(min_rank(-(dep_delay)) %in% 1:10)
# A tibble: 10 x 19
    year month   day dep_time sched_dep_time dep_delay arr_time sched_arr_time arr_delay carrier flight tailnum origin dest 
   <int> <int> <int>    <int>          <int>     <dbl>    <int>          <int>     <dbl> <chr>    <int> <chr>   <chr>  <chr>
 1  2013     1     9      641            900      1301     1242           1530      1272 HA          51 N384HA  JFK    HNL  
 2  2013     1    10     1121           1635      1126     1239           1810      1109 MQ        3695 N517MQ  EWR    ORD  
 3  2013    12     5      756           1700       896     1058           2020       878 AA         172 N5DMAA  EWR    MIA  
 4  2013     3    17     2321            810       911      135           1020       915 DL        2119 N927DA  LGA    MSP  
 5  2013     4    10     1100           1900       960     1342           2211       931 DL        2391 N959DL  JFK    TPA  
 6  2013     6    15     1432           1935      1137     1607           2120      1127 MQ        3535 N504MQ  JFK    CMH  
 7  2013     6    27      959           1900       899     1236           2226       850 DL        2007 N3762Y  JFK    PDX  
 8  2013     7    22      845           1600      1005     1044           1815       989 MQ        3075 N665MQ  JFK    CVG  
 9  2013     7    22     2257            759       898      121           1026       895 DL        2047 N6716C  LGA    ATL  
10  2013     9    20     1139           1845      1014     1457           2210      1007 AA         177 N338AA  JFK    SFO  
# ... with 5 more variables: air_time <dbl>, distance <dbl>, hour <dbl>, minute <dbl>, time_hour <dttm>
> 
> flights %>%
+ top_n(10,dep_delay)
# A tibble: 10 x 19
    year month   day dep_time sched_dep_time dep_delay arr_time sched_arr_time arr_delay carrier flight tailnum origin dest 
   <int> <int> <int>    <int>          <int>     <dbl>    <int>          <int>     <dbl> <chr>    <int> <chr>   <chr>  <chr>
 1  2013     1     9      641            900      1301     1242           1530      1272 HA          51 N384HA  JFK    HNL  
 2  2013     1    10     1121           1635      1126     1239           1810      1109 MQ        3695 N517MQ  EWR    ORD  
 3  2013    12     5      756           1700       896     1058           2020       878 AA         172 N5DMAA  EWR    MIA  
 4  2013     3    17     2321            810       911      135           1020       915 DL        2119 N927DA  LGA    MSP  
 5  2013     4    10     1100           1900       960     1342           2211       931 DL        2391 N959DL  JFK    TPA  
 6  2013     6    15     1432           1935      1137     1607           2120      1127 MQ        3535 N504MQ  JFK    CMH  
 7  2013     6    27      959           1900       899     1236           2226       850 DL        2007 N3762Y  JFK    PDX  
 8  2013     7    22      845           1600      1005     1044           1815       989 MQ        3075 N665MQ  JFK    CVG  
 9  2013     7    22     2257            759       898      121           1026       895 DL        2047 N6716C  LGA    ATL  
10  2013     9    20     1139           1845      1014     1457           2210      1007 AA         177 N338AA  JFK    SFO  
# ... with 5 more variables: air_time <dbl>, distance <dbl>, hour <dbl>, minute <dbl>, time_hour <dttm>

# What does 1:3 + 1:10 return? Why?
> 1:3 + 1:10
 [1]  2  4  6  5  7  9  8 10 12 11
Warning message:
In 1:3 + 1:10 :
  longer object length is not a multiple of shorter object length
> 1:10 + 1:3
 [1]  2  4  6  5  7  9  8 10 12 11
Warning message:
In 1:10 + 1:3 :
  longer object length is not a multiple of shorter object length
  
 What trigonometric functions does R provide?
 ? Trig
 
5.6 Grouped summaries with summarise()
summarise(flights, delay = mean(dep_delay, na.rm= TRUE))
# A tibble: 1 x 1
delay
<dbl>
  1  12.6

> by_day <- group_by(flights, year, month, day)
> summarise( by_day, delay= mean(dep_delay, na.rm=TRUE))
# A tibble: 365 x 4
# Groups:   year, month [12]
year month   day delay
<int> <int> <int> <dbl>
  1  2013     1     1 11.5 
2  2013     1     2 13.9 
3  2013     1     3 11.0 
4  2013     1     4  8.95
5  2013     1     5  5.73
6  2013     1     6  7.15
7  2013     1     7  5.42
8  2013     1     8  2.55
9  2013     1     9  2.28
10  2013     1    10  2.84
# ... with 355 more rows

5.6.1 Combining multiple operations with the pipe

magine that we want to explore the relationship between the distance and 
average delay for each location. Using what you know about dplyr, you might 
write code like this:

  > by_dest <- group_by(flights, dest)
> delay<-summarise(by_dest,
                   + count=n(),
                   + dist=mean(distance, na.rm=TRUE),
                   + delay=mean(arr_delay, na.rm=TRUE)
                   + )


> delay <- filter(delay, count > 20, dest != "HNL")

ggplot(data=delay, mapping=aes(x=dist, y= delay))+
  +    geom_point(aes(size=count),alpha=1/3, color=2)+
  +    geom_smooth()

There are three steps to prepare this data:
Group flights by destination.
Summarise to compute distance, average delay, and number of flights.
Filter to remove noisy points and Honolulu airport, 
which is almost twice as far away as the next closest airport.

There’s another way to tackle the same problem with the pipe, %>%:
  
  delays <- flights %>% 
  group_by(dest) %>% 
  summarise(
    count = n(),
    dist = mean(distance, na.rm = TRUE),
    delay = mean(arr_delay, na.rm = TRUE)
  ) %>% 
  filter(count > 20, dest != "HNL")

5.6.2 Missing values

if we don’t set na.rm argument

> flights %>%
  + group_by(year, month, day) %>%
  + summarise(mean=mean(dep_delay))
# A tibble: 365 x 4
# Groups:   year, month [12]
year month   day  mean
<int> <int> <int> <dbl>
  1  2013     1     1    NA
2  2013     1     2    NA
3  2013     1     3    NA
4  2013     1     4    NA
5  2013     1     5    NA
6  2013     1     6    NA
7  2013     1     7    NA
8  2013     1     8    NA
9  2013     1     9    NA
10  2013     1    10    NA
# ... with 355 more rows

#Adding na.rm=TRUE

> flights %>%
  + group_by(year,month,day) %>%
  + summarise(mean=mean(dep_delay, na.rm=TRUE))
# A tibble: 365 x 4
# Groups:   year, month [12]
year month   day  mean
<int> <int> <int> <dbl>
  1  2013     1     1 11.5 
2  2013     1     2 13.9 
3  2013     1     3 11.0 
4  2013     1     4  8.95
5  2013     1     5  5.73
6  2013     1     6  7.15
7  2013     1     7  5.42
8  2013     1     8  2.55
9  2013     1     9  2.28
10  2013     1    10  2.84
# ... with 355 more rows

#HOW TO REMOVE CANCELLED FLIGHTS.
remove parts without values

> not_cancelled <- flights %>%
  + filter(!is.na(dep_delay), !is.na(arr_delay))
> 
  > not_cancelled %>%
  + group_by(year,month, day) %>%
  + summarise(mean=mean(dep_delay))
# A tibble: 365 x 4
# Groups:   year, month [12]
year month   day  mean
<int> <int> <int> <dbl>
  1  2013     1     1 11.4 
2  2013     1     2 13.7 
3  2013     1     3 10.9 
4  2013     1     4  8.97
5  2013     1     5  5.73
6  2013     1     6  7.15
7  2013     1     7  5.42
8  2013     1     8  2.56
9  2013     1     9  2.30
10  2013     1    10  2.84
# ... with 355 more rows

5.6.3 Counts
Whenever you do any aggregation, 
it’s always a good idea to include either a count (n()), 
or a count of non-missing values (sum(!is.na(x)))

For example, let’s look at the planes (identified by their tail number) that have the highest average delays:

  > delays <- not_cancelled %>%
  + group_by(tailnum) %>%
  + summarise(
    + delay=mean(arr_delay))

  > ggplot(data=delays, mapping= aes(x=delay))+
  + geom_freqpoly(binwidth=10)

The story is actually a little more nuanced. 
get more insight if we draw a scatterplot of number of flights vs. average delay:
  
  delays <- not_cancelled %>% 
  group_by(tailnum) %>% 
  summarise(
    delay = mean(arr_delay, na.rm = TRUE),
    n = n()
  )

ggplot(data = delays, mapping = aes(x = n, y = delay)) + 
  geom_point(alpha = 1/10)



install.packages("Lahman")

library("Lahman")

# Convert to a tibble so it prints nicely
batting <- as_tibble(Lahman::Batting)

batters<- batting %>%
  + group_by(playerID) %>%
  + summarise(
    + ba= sum(H, na.rm =TRUE)/ sum(AB, na.rm=TRUE),
    + ab= sum(AB, na.rm= TRUE)
    + )

batters %>%
  + filter(ab> 100) %>%
  + ggplot(mapping= aes(x=ab, y=ba))+
  + geom_point()+
  + geom_smooth(se=FALSE)



> batters %>%
  + arrange( desc(ba))
# A tibble: 19,428 x 3
playerID     ba    ab
<chr>     <dbl> <int>
  1 abramge01     1     1
2 alberan01     1     1
3 allarko01     1     1
4 banisje01     1     1
5 bartocl01     1     1
6 bassdo01      1     1
7 birasst01     1     2
8 bruneju01     1     1
9 burnscb01     1     1
10 cammaer01     1     1
# ... with 19,418 more rows

5.6.4 Useful summary functions

> not_cancelled %>%
  + group_by(year, month, day) %>%
  + summarise(
    + avg_delay1=mean(arr_delay),
    + avg_delay2=mean(arr_delay[arr_delay>0]))
# A tibble: 365 x 5
# Groups:   year, month [12]
year month   day avg_delay1 avg_delay2
<int> <int> <int>      <dbl>      <dbl>
  1  2013     1     1     12.7         32.5
2  2013     1     2     12.7         32.0
3  2013     1     3      5.73        27.7
4  2013     1     4     -1.93        28.3
5  2013     1     5     -1.53        22.6
6  2013     1     6      4.24        24.4
7  2013     1     7     -4.95        27.8
8  2013     1     8     -3.23        20.8
9  2013     1     9     -0.264       25.6
10  2013     1    10     -5.90        27.3
# ... with 355 more rows

not_cancelled %>%
  + group_by(dest) %>%
  + summarise(distance_sd = sd(distance)) %>%
  + arrange(desc(distance_sd))
# A tibble: 104 x 2
dest  distance_sd
<chr>       <dbl>
  1 EGE         10.5 
2 SAN         10.4 
3 SFO         10.2 
4 HNL         10.0 
5 SEA          9.98
6 LAS          9.91
7 PDX          9.87
8 PHX          9.86
9 LAX          9.66
10 IND          9.46
# ... with 94 more rows
> 
  
  # When do the first and last flights leave each day?

  > not_cancelled %>%
  + group_by (year, month, day) %>%
  + summarise(
    + first_dep= first(dep_time),
    + last_dep=last(dep_time)
    + )
# A tibble: 365 x 5
# Groups:   year, month [12]
year month   day first_dep last_dep
<int> <int> <int>     <int>    <int>
  1  2013     1     1       517     2356
2  2013     1     2        42     2354
3  2013     1     3        32     2349
4  2013     1     4        25     2358
5  2013     1     5        14     2357
6  2013     1     6        16     2355
7  2013     1     7        49     2359
8  2013     1     8       454     2351
9  2013     1     9         2     2252
10  2013     1    10         3     2320
# ... with 355 more rows

Batters Data Set
batting <- as_tibble(Lahman::Batting)
> 
  > batting
# A tibble: 105,861 x 22
playerID yearID stint teamID lgID      G    AB     R     H   X2B   X3B    HR   RBI    SB    CS    BB
<chr>     <int> <int> <fct>  <fct> <int> <int> <int> <int> <int> <int> <int> <int> <int> <int> <int>
  1 abercda~   1871     1 TRO    NA        1     4     0     0     0     0     0     0     0     0     0
2 addybo01   1871     1 RC1    NA       25   118    30    32     6     0     0    13     8     1     4
3 allisar~   1871     1 CL1    NA       29   137    28    40     4     5     0    19     3     1     2
4 allisdo~   1871     1 WS3    NA       27   133    28    44    10     2     2    27     1     1     0
5 ansonca~   1871     1 RC1    NA       25   120    29    39    11     3     0    16     6     2     2
6 armstbo~   1871     1 FW1    NA       12    49     9    11     2     1     0     5     0     1     0
7 barkeal~   1871     1 RC1    NA        1     4     0     1     0     0     0     2     0     0     1
8 barnero~   1871     1 BS1    NA       31   157    66    63    10     9     0    34    11     6    13
9 barrebi~   1871     1 FW1    NA        1     5     1     1     1     0     0     1     0     0     0
10 barrofr~   1871     1 BS1    NA       18    86    13    13     2     1     0    11     1     0     0
# ... with 105,851 more rows, and 6 more variables: SO <int>, IBB <int>, HBP <int>, SH <int>, SF <int>,


batters <- batting %>%
  group_by(playerID) %>%
  summarise(
    ba=sum(H, na.rm=TRUE/ sum(AB, na.rm=TRUE),
    ab=sum(AB, na.rm=TRUE)
    )
    
batters

> batters
# A tibble: 19,428 x 3
playerID      ba    ab
<chr>      <dbl> <int>
  1 aardsda01 0          4
2 aaronha01 0.305  12364
3 aaronto01 0.229    944
4 aasedo01  0          5
5 abadan01  0.0952    21
6 abadfe01  0.111      9
7 abadijo01 0.224     49
8 abbated01 0.254   3044
9 abbeybe01 0.169    225
10 abbeych01 0.281   1756
# ... with 19,418 more rows

#CONVERT batters to a ggplot

batters %>%
  filter(ab>100) %>%
  ggplot(mapping=aes(x=ab,y=ba))+
  geom_point()+
  geom_smooth(se=FALSE)

naively sort on desc(ba), 
people with the best batting averages are clearly lucky, 
NOT SKILLED:
  > batters %>%
  + arrange(desc(ba))
# A tibble: 19,428 x 3
playerID     ba    ab
<chr>     <dbl> <int>
  1 abramge01     1     1
2 alberan01     1     1
3 allarko01     1     1
4 banisje01     1     1
5 bartocl01     1     1
6 bassdo01      1     1
7 birasst01     1     2
8 bruneju01     1     1
9 burnscb01     1     1
10 cammaer01     1     1
# ... with 19,418 more rows

5.6.4 Useful summary functions


not_cancelled %>%
  group_by(year, month, day) %>%
  summarise(
    avg_delay1=mean(arr_delay),
    avg_delay2=mean(arr_delay[arr_delay>0]) # the average postive delay
  )

# A tibble: 365 x 5
# Groups:   year, month [12]
year month   day avg_delay1 avg_delay2
<int> <int> <int>      <dbl>      <dbl>
  1  2013     1     1     12.7         32.5
2  2013     1     2     12.7         32.0
3  2013     1     3      5.73        27.7
4  2013     1     4     -1.93        28.3
5  2013     1     5     -1.53        22.6
6  2013     1     6      4.24        24.4
7  2013     1     7     -4.95        27.8
8  2013     1     8     -3.23        20.8
9  2013     1     9     -0.264       25.6
10  2013     1    10     -5.90        27.3
# ... with 355 more rows

# why distance to some destinations more variable than to others?
not_cancelled %>%
  group_by(dest) %>%
  summarise(distance_sd=sd(distance)) %>%
  arrange(desc(distance_sd))

# A tibble: 104 x 2
dest  distance_sd
<chr>       <dbl>
  1 EGE         10.5 
2 SAN         10.4 
3 SFO         10.2 
4 HNL         10.0 
5 SEA          9.98
6 LAS          9.91
7 PDX          9.87
8 PHX          9.86
9 LAX          9.66
10 IND          9.46
# ... with 94 more rows

Measures of rank: min(x), quantile(x, 0.25), max(x). 
uantiles are a generalisation of the median. 
or example, quantile(x, 0.25) will find a value of x 
hat is greater than 25% of the values, 
nd less than the remaining 75%.

# When do the first and last flights leave each day?

not_cancelled %>%
  group_by(year, month, day) %>%
  summarise(
    first = min(dep_time),
    last=max(dep_time)
  )

# A tibble: 365 x 5
# Groups:   year, month [12]
year month   day first  last
<int> <int> <int> <int> <int>
  1  2013     1     1   517  2356
2  2013     1     2    42  2354
3  2013     1     3    32  2349
4  2013     1     4    25  2358
5  2013     1     5    14  2357
6  2013     1     6    16  2355
7  2013     1     7    49  2359
8  2013     1     8   454  2351
9  2013     1     9     2  2252
10  2013     1    10     3  2320
# ... with 355 more rows

ranking.
Measures of position: first(x), nth(x, 2), last(x). 
hese work similarly to x[1], x[2], and x[length(x)] 
ut let you set a default value if that position does not exist 
i.e. you’re trying to get the 3rd element from a group that only has two elements). 
or example, we can find the first and last departure for each day:

not_cancelled %>%
  group_by(year, month, day) %>%
  summarise(
    fist_dep=first(dep_time),
    last_dep=last(dep_time)
  )

# A tibble: 365 x 5
# Groups:   year, month [12]
year month   day fist_dep last_dep
<int> <int> <int>    <int>    <int>
  1  2013     1     1      517     2356
2  2013     1     2       42     2354
3  2013     1     3       32     2349
4  2013     1     4       25     2358
5  2013     1     5       14     2357
6  2013     1     6       16     2355
7  2013     1     7       49     2359
8  2013     1     8      454     2351
9  2013     1     9        2     2252
10  2013     1    10        3     2320
# ... with 355 more rows

Filtering gives you all variables, with each observation in a separate row:

 
  not_cancelled %>%
  group_by(year, month, day) %>%
  mutate(r=min_rank(desc(dep_time))) %>%
  filter( r %in% range (r))

# A tibble: 770 x 20
# Groups:   year, month, day [365]
year month   day dep_time sched_dep_time dep_delay arr_time sched_arr_time arr_delay carrier flight
<int> <int> <int>    <int>          <int>     <dbl>    <int>          <int>     <dbl> <chr>    <int>
  1  2013     1     1      517            515         2      830            819        11 UA        1545
2  2013     1     1     2356           2359        -3      425            437       -12 B6         727
3  2013     1     2       42           2359        43      518            442        36 B6         707
4  2013     1     2     2354           2359        -5      413            437       -24 B6         727
5  2013     1     3       32           2359        33      504            442        22 B6         707
6  2013     1     3     2349           2359       -10      434            445       -11 B6         739
7  2013     1     4       25           2359        26      505            442        23 B6         707
8  2013     1     4     2358           2359        -1      429            437        -8 B6         727
9  2013     1     4     2358           2359        -1      436            445        -9 B6         739
10  2013     1     5       14           2359        15      503            445        18 B6         739
# ... with 760 more rows, and 9 more variables: tailnum <chr>, origin <chr>, dest <chr>, air_time <dbl>,
#   distance <dbl>, hour <dbl>, minute <dbl>, time_hour <dttm>, r <int>

To count the number of non-missing values, use sum(!is.na(x)). 
To count the number of distinct (unique) values, use n_distinct(x)

# Which destinations have the most carriers?

not_cancelled %>%
  group_by(dest) %>%
  summarise(carriers= n_distinct(carrier)) %>%
  arrange(desc(carriers))

# A tibble: 104 x 2
dest  carriers
<chr>    <int>
  1 ATL          7
2 BOS          7
3 CLT          7
4 ORD          7
5 TPA          7
6 AUS          6
7 DCA          6
8 DTW          6
9 IAD          6
10 MSP          6
# ... with 94 more rows

Counts are so useful that dplyr provides a simple helper if all you want is a count:
  not_cancelled %>%
  count(dest) %>%

  # A tibble: 104 x 2
  dest      n
<chr> <int>
  1 XNA     992
2 TYS     578
3 TVC      95
4 TUL     294
5 TPA    7390
6 SYR    1707
7 STT     518
8 STL    4142
9 SRQ    1201
10 SNA     812
# ... with 94 more rows

not_cancelled %>%
  count(dest) %>%
  arrange(desc(n))

# A tibble: 104 x 2
dest      n
<chr> <int>
  1 ATL   16837
2 ORD   16566
3 LAX   16026
4 BOS   15022
5 MCO   13967
6 CLT   13674
7 SFO   13173
8 FLL   11897
9 MIA   11593
10 DCA    9111
# ... with 94 more rows

“count” (sum) the total number of miles a plane flew

not_cancelled %>%
  count(tailnum, wt=distance)

# A tibble: 4,037 x 2
tailnum      n
<chr>    <dbl>
  1 D942DN    3418
2 N0EGMQ  239143
3 N10156  109664
4 N102UW   25722
5 N103US   24619
6 N104UW   24616
7 N10575  139903
8 N105UW   23618
9 N107US   21677
10 N108UW   32070
# ... with 4,027 more rows

not_cancelled %>%
  count(tailnum, wt=distance) %>%
  arrange(desc(n))

# A tibble: 4,037 x 2
tailnum      n
<chr>    <dbl>
  1 N328AA  929090
2 N338AA  921172
3 N335AA  902271
4 N327AA  900482
5 N323AA  839468
6 N319AA  837924
7 N336AA  833136
8 N329AA  825826
9 N324AA  786159
10 N339AA  783648

not_cancelled %>%
  count(tailnum, wt=distance) %>%
  arrange(-desc(n))

# A tibble: 4,037 x 2
tailnum     n
<chr>   <dbl>
  1 N505SW    185
2 N746SK    229
3 N881AS    292
4 N824AS    296
5 N701SK    419
6 N702SK    419
7 N705SK    419
8 N710SK    419
9 N726SK    419
10 N740SK    419
# ... with 4,027 more rows

# How many flights left before 5am? (these usually indicate delayed
# flights from the previous day)

not_cancelled %>%
  group_by(year,month, day) %>%
  summarise(n_early=sum(dep_time<500))

# A tibble: 365 x 4
# Groups:   year, month [12]
year month   day n_early
<int> <int> <int>   <int>
  1  2013     1     1       0
2  2013     1     2       3
3  2013     1     3       4
4  2013     1     4       3
5  2013     1     5       3
6  2013     1     6       2
7  2013     1     7       2
8  2013     1     8       1
9  2013     1     9       3
10  2013     1    10       3
# ... with 355 more rows

> # What proportion of flights are delayed by more than an hour?

  > not_cancelled %>%
  + group_by(year, month, day) %>%
  + summarise(hour_perc=mean(arr_delay>60))

# A tibble: 365 x 4
# Groups:   year, month [12]
year month   day hour_perc
<int> <int> <int>     <dbl>
  1  2013     1     1    0.0722
2  2013     1     2    0.0851
3  2013     1     3    0.0567
4  2013     1     4    0.0396
5  2013     1     5    0.0349
6  2013     1     6    0.0470
7  2013     1     7    0.0333
8  2013     1     8    0.0213
9  2013     1     9    0.0202
10  2013     1    10    0.0183
# ... with 355 more rows

#flights that left before 5 and has 10 minutes delay
# can combine, summary
not_cancelled %>%
  group_by(year, month, day) %>%
  summarise(n_early=sum(dep_time<500, hour_perc=mean(arr_delay>10))
  )

# A tibble: 365 x 4
# Groups:   year, month [12]
year month   day n_early
<int> <int> <int>   <dbl>
  1  2013     1     1   0.367
2  2013     1     2   3.37 
3  2013     1     3   4.34 
4  2013     1     4   3.21 
5  2013     1     5   3.17 
6  2013     1     6   2.29 
7  2013     1     7   2.14 
8  2013     1     8   1.15 
9  2013     1     9   3.18 
10  2013     1    10   3.12 
# ... with 355 more rows

5.6.5 Grouping by multiple variables

group by multiple variables, 
each summary peels off one level of the grouping. 
that makes it easy to progressively roll up a dataset:

 daily <- group_by(flights, year, month, day)

daily #will produce a tibble grouped by year, month and day
# A tibble: 336,776 x 19
# Groups:   year, month, day [365]
year month   day dep_time sched_dep_time dep_delay arr_time sched_arr_time arr_delay carrier flight
<int> <int> <int>    <int>          <int>     <dbl>    <int>          <int>     <dbl> <chr>    <int>
  1  2013     1     1      517            515         2      830            819        11 UA        1545
2  2013     1     1      533            529         4      850            830        20 UA        1714
3  2013     1     1      542            540         2      923            850        33 AA        1141
4  2013     1     1      544            545        -1     1004           1022       -18 B6         725
5  2013     1     1      554            600        -6      812            837       -25 DL         461
6  2013     1     1      554            558        -4      740            728        12 UA        1696
7  2013     1     1      555            600        -5      913            854        19 B6         507
8  2013     1     1      557            600        -3      709            723       -14 EV        5708
9  2013     1     1      557            600        -3      838            846        -8 B6          79
10  2013     1     1      558            600        -2      753            745         8 AA         301
# ... with 336,766 more rows, and 8 more variables: tailnum <chr>, origin <chr>, dest <chr>,
#   air_time <dbl>, distance <dbl>, hour <dbl>, minute <dbl>, time_hour <dttm>

per_day <-summarise(daily, flights=n())
per_day
# A tibble: 365 x 4
# Groups:   year, month [12]
year month   day flights
<int> <int> <int>   <int>
  1  2013     1     1     842
2  2013     1     2     943
3  2013     1     3     914
4  2013     1     4     915
5  2013     1     5     720
6  2013     1     6     832
7  2013     1     7     933
8  2013     1     8     899
9  2013     1     9     902
10  2013     1    10     932
# ... with 355 more rows

per_month <- summarise(per_day, flights= sum(flights))
per_month

# Groups:   year [1]
year month flights
<int> <int>   <int>
  1  2013     1   27004
2  2013     2   24951
3  2013     3   28834
4  2013     4   28330
5  2013     5   28796
6  2013     6   28243
7  2013     7   29425
8  2013     8   29327
9  2013     9   27574
10  2013    10   28889
11  2013    11   27268
12  2013    12   28135

per_year <-summarise(per_month, flights=sum(flights))
per_year
# A tibble: 1 x 2
year flights
<int>   <int>
  1  2013  336776

#this is applicable to sum, but not medians
the sum of groupwise sums is the overall sum, 
but the median of groupwise medians is not the overall median

5.6.6 Ungrouping

daily %>%
  ungroup() %>%   #no longer grouped by date
  summarise(flights=n()) #all flights
  
  5.6.7 Exercises
  
